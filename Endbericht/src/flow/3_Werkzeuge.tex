\subsection{Werkzeuge}
Die Entwicklung von Anwendungen für Mikrocontroller bietet eine Reihe von Besonderheiten, insbesondere durch die begrenzte Beobachtbarkeit und Kontrolle zur Laufzeit der Ausführung. Entsprechend müssen auch die genutzten Werkzeuge über spezielle Funktionalitäten verfügen, um die Entwicklung trotzdem effizient zu gestalten. Die in dieser Projektgruppe eingesetzten Tools sollen nun im Folgenden kurz vorgestellt werden.

\subsubsection{Atmel Studio}
Atmel Studio (vormals AVR Studio) ist eine integrierte Entwicklungsumgebung für eingebettete Systeme, insbesondere für die Atmel-eigenen Mikrocontrollerfamilien.
Es basiert auf Microsoft Visual Studio, eignet sich aber insbesondere für die Entwicklung von Software für eingebettete 8- und 32-Bit Controller mit C, C++ und Assembler.
Kern der Anwendung ist ein Cross-Compiler, der es erlaubt, ausführbare Binärdateien direkt für die Zielhardware zu kompilieren.

Abbildung \autoref{fig:avrstudio1} zeigt einen Screenshot vom Atmel Studio. Das Hauptfenster links zeigt die Code-Ansicht mit farblich markierter Code-Struktur, während rechts die Dateistruktur des Projekts abgebildet ist.

\begin{figure}[!t]
  \centering
    \includegraphics[width = 0.85\textwidth]{flow/AVRStudio_1.png}
    \caption{Entwicklungs-Ansicht des Atmel Studio}
    \label{fig:avrstudio1}
\end{figure}

\begin{figure}[!h]
  \centering
    \includegraphics[width = 0.85\textwidth]{flow/AVRStudio_2.png}
    \caption{Debugging-Ansicht des Atmel Studio}
    \label{fig:avrstudio2}
\end{figure}

Neben dem Cross-Compiler beinhaltet das Atmel Studio auch einen Simulator, der es erlaubt, die Ausführung der entwickelten Software auf der Zielhardware zu simulieren. Dabei können Register, Hauptspeicher und Pins des Zielcontrollers beobachtet und Haltepunkte im Code gesetzt werden. Die Simulation ist um ein vielfaches langsamer als die Ausführung auf echter Hardware, sodass sie etwa für das Testen von Zeitschranken kaum in Frage kommt, allerdings gibt sie einen ersten Eindruck von der Funktionalität der eigenen Anwendung.

\subsubsection{Atmel JTAGICE3}
\label{sec:JTAGICE3}
Die Probleme der simulationsbasierten Ausführung der entwickelten Anwendung sind vor allem die üblicherweise deutlich niedrigere Geschwindigkeit im Vergleich mit der Ausführung auf der Zielhardware und zum Anderen die fehlende Peripherie, sodass angeschlossene Sensoren, Aktoren oder andere Hardwarebausteine, wie der CC2420-Funkchip der \textsc{Mica}z-Module, nicht getestet werden können.

Eine Lösung bietet der Atmel JTAGICE3, der über eine JTAG-Schnittstelle direkt auf die Zielhardware zugreifen und ihren Zustand auslesen und verändern kann. \textbf{JTAG} steht für \textit{Joint Test Action Group} und ist eine standardisierte (IEEE Standard 1149.1, siehe \cite{IEEE1149:2014:Online}) Schnittstelle für das Programmieren und das Debuggging von integrierten Schaltungen. Es erlaubt - ähnlich wie das simulationsbasierten Debugging - den direkten Zugriff auf Register- und Speicherwerte, allerdings erfolgt der Zugriff direkt auf der Hardware. 