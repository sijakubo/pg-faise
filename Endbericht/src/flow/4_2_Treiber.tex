\subsubsection{Background Level: Treiber, Services und Interfaces}
Im Background Level werden Teiber, die sich um die Schnittstellen/Pins des Controllers wie z.~B. Protokolle angeschlossener Devices\cite[S. 26]{Stasch:Hahn} kümmern, Services, deren Aufgabe es ist, die Funktionen der Treiber zu sinnvollen Einheiten zusammenzufassen, und schließlich Interfaces, die genutzt werden, um die Funktionen der Services dem AgentenRTE zur Verfügung zu stellen und gleichzeitig plattformabhängige Implementierungsdetails zu maskieren, implementiert \cite[S. 26]{Stasch:Hahn}. Im Laufe der Projektarbeit wurden unterschiedliche Treiber, Services und Interfaces entwickelt. Der folgende Abschnitt soll diese einzeln näher beleuchten.

\paragraph{Treiber Bolzen}
Folgende Funktionen werden im Treiber für die Bolzen bereitgestellt:
\begin{itemize}
  \item void BoltDriver\_init(void)
  \item void BoltDriver\_up(unsigned char boltv)
  \item void BoltDriver\_down(unsigned char boltv)
  \item uint8\_t BoltDriver\_get(void)
\end{itemize} 
Die Funktion \textit{void BoltDriver\_init(void)} dient zur Initialisierung. Dabei werden die Ports der \textsc{Mica}z-Module, die für die Bolzensteuerung nötig sind, als Ausgänge festgelegt und gleichzeitig auf HIGH-Aktiv gesetzt.

Zum Öffnen der Bolzen wird die Funktion \textit{void BoltDriver\_down(unsigned char boltv)} genutzt. Ihr wird ein Vektor übergeben, der die Pinbelegung von den zu öffnenden Bolzen enthält. Da die Bolzen beim öffnen jeweils eine Anfansspannung von 24 Volt benötigen, muss darauf geachtet werden, dass die Bolzen nacheinander geöffnet werden. Im ersten Schritt fragt die Funktion ab, ob Bolzen 1 geöffnet werden soll. Bei erfolgreicher Prüfung, werden Pin 1 und 2 der ersten Bolzen angeschaltet, wodurch eine Anfangsspannung von 24 Volt anliegt und der Bolzen sich öffnen kann. Damit das Öffnen erfolgreich sichergestellt werden kann, wird dieser Zustand über 60 Taktzyklen gehalten, dann wird der zweite Pin wieder ausgeschaltet. Jetzt liegen über den angeschlossenen Verstärker noch 12 Volt Spannung an, was ausreicht um den Bolzen offen zu halten, ohne die Schaltung zu überhitzen. Im nächsten Schritt wird überprüft ob beide Bolzen gleichzeitig geöffnet werden sollen. Ist dies der Fall, dann wird wieder für 60 Taktzyklen im System gewartet. Im Anschluss daran wird kontrolliert, ob Bolzen 2 geöffnet werden soll. Liegt hier eine positive Bewertung vor, wird mit den Pins von Bolzen 2 analog zu Bolzen 1 vorgegangen.

Die Funktion \textit{void BoltDriver\_up(unsigned char boltv)} schließt die Bolzen. Dieser Funktion wird ebenfalls ein Vektor übergeben, der die Belegung der Bolzen enthält, die geschlossen werden sollen. Dabei wird geprüft, welche Bolzen geschlossen werden sollen. Anschließend werden dann jeweils beide Pins der Bolzen auf LOW gezogen, ein sukzessives \textit{Herunterfahren} der Spannung wie beim Öffnen ist nicht nötig.

Mit der Funkion \textit{uint8\_t BoltDriver\_get(void)} kann die Bolzenstellung abgefragt werden. Dabei wird einfach überprüft, ob die Ausgänge des \textsc{Mica}z-Modul an denen die Bolzen angeschlossen sind HIGH sind. Beim Rückgabevektor steht eine Eins im Vektor für einen offenen und eine Null für einen geschlossenen Bolzen.

\paragraph{Interface Bolzen}
Das Bolzen-Interface greift direkt auf die Treiber der Bolzen zu und stellt mehrere Funktionen zur Verfügung, durch die Prozesse gestartet werden. Die unterschiedlich bereitgestellten Funkionen im Bolzen-Interface sind:
\begin{itemize}
  \item void BoltInterface\_init(void);
  \item void BoltInterface\_release(void);
  \item void BoltInterface\_release\_and\_separate(void);
  \item void BoltInterface\_separate(void);
\end{itemize}

Durch die unteren drei Funktionen werden folgende Prozesse gestartet:
\begin{itemize}
  \item PROCESS\_NAME(bolt\_int\_release)
  \item PROCESS\_NAME(bolt\_int\_release\_and\_separate)
  \item PROCESS\_NAME(bolt\_int\_separate)
\end{itemize}

Der Prozess \textit{bolt\_int\_release} ist dafür zuständig, die untersten zwei Bolzen für einen bestimmten Zeitraum zu öffnen und dann wieder zu schließen. Dafür existieren zwei Zustände. Im ersten Zustand wird die Funktion \textit{BoltDriver\_up(unsigned char boltv)} aufgerufen. So wird sichergestellt, dass die oberen beiden Bolzen geschlossen sind, um nur exakt ein Paket freizugeben. Nach dem Aufruf der Funktion wird ein Timer gestartet. Zustand zwei ruft, sobald der Timer abläuft, die Funktion \textit{BoltDriver\_down(unsigned char boltv)} aus dem Treiber mit einem Vektor für die unteren beiden Bolzen auf und das Paket wird freigegeben. Im Anschluss daran, wird wieder ein Timeout gesetzt und gewartet. Nach dem Durchlauf der zwei Zustände wird vorm Prozessende die Funktion \textit{BoltDriver\_up(unsigned char boltv)} aus den Treibern aufgerufen, um die unteren Bolzen wieder zu schließen.

Um Pakete nicht nur von der Rampe auszugeben, sondern auch gleich das nächste Paket zu separieren, ist der Prozess \textit{bolt\_int\_release\_and\_separate} zuständig. Dabei werden zu Anfang des Prozesses vier unterschiedliche Zustände durchlaufen. Die ersten drei Zustände sind dafür da, das Paket von der Rampe zu entfernen. Hierbei wird genau wie oben beim der Funktion \textit{bolt\_int\_release} vorgegangen. Zustand vier wird im Anschluss daran dann benutzt, die oberen Bolzen wieder zu öffnen, damit das nächste Paket nachrutschen kann. Vorm Abschluss des Prozesses werden diese dannn wieder durch die Treiberfunktion \textit{BoltDriver\_up(unsigned char boltv)} geschlossen.

Mit dem dritten Prozess wird es ermöglicht, die oberen zwei Bolzen zu öffnen. Beim Prozessdurchlauf wird im Zustand eins sichergestellt, dass die unteren beiden Bolzen geschlossen sind. Im zweiten Zustand werden dann die oberen zwei Bolzen geöffnet, was ein Nachrutschen von Paketen ermöglicht. Bevor der Prozess dann beendet wird, werden die beiden Bolzen wieder geschlossen. Der Prozess ermöglicht es somit, ein Paket zu separieren.

\paragraph{Treiber Externer Speicher}
\label{sec:externalMemory}
Der Treiber für den externen Speicher setzt den SPI-Bus zum AT45DB041-Chip um. Dafür nutzt er die Pins D2 (RXD oder SO), D3 (TXD oder SI), D5 (SCK) und A3 (CS). Ein Befehl an den Speicher ist dabei stets gleich aufgebaut:
\begin{itemize}
\item 1 Byte Opcode
\item 4 Don't-Care-Bits und 11 Bit Seiten-Adresse
\item 9 Bit Buffer-Adresse
\item Read Trigger (nur für Lese-Befehle, Senden von ebenso vielen leeren Bytes wie empfangen werden sollen)
\end{itemize}

Der Treiber stellt folgende Funktionen zur Verfügung:

\begin{itemize}
  \item void ExtflashDriver\_init()
  \item uint8\_t ExtflashDriver\_tr\_byte(uint8\_t spiOut)
  \item void ExtflashDriver\_enable()
  \item void ExtflashDriver\_disable()
  \item void ExtflashDriver\_wait\_idle()
  \item uint8\_t ExtflashDriver\_read\_status\_register(void)
  \item uint8\_t ExtflashDriver\_get\_last\_compare(void)
\end{itemize}

Bemerkenswert ist hier insbesondere die Funktion \textit{ExtflashDriver\_tr\_byte}. Entsprechend des SPI-Busses sendet und empfängt sie gleichzeitig ein Byte vom Speicher.  \textit{ExtflashDriver\_wait\_idle} empfängt das erste Byte des Statusregisters. So kann geprüft werden, ob der Speicherchip gerade eine Seite in den Buffer lädt oder den Buffer zurückschreibt und deshalb mit dem nächsten Befehl gewartet werden muss \cite{AT45DB041A:2014:Online}.
\paragraph{Interface Externer Speicher}
Das Interface stellt für das Speicherinterface folgende Funktionen zur Verfügung:
\begin{itemize}
  \item void ExtflashInterface\_init()
  \item void ExtflashInterface\_restore(uint16\_t cell)
  \item void ExtflashInterface\_flush(uint16\_t cell)
  \item void ExtflashInterface\_agent\_restore(uint8\_t localAgentId)
  \item void ExtflashInterface\_agent\_flush(uint8\_t localAgentId)
  \item uint8\_t ExtflashInterface\_write(uint16\_t address, uint8\_t* data, uint8\_t len)
  \item uint8\_t ExtflashInterface\_read(uint16\_t address, uint8\_t* data, uint8\_t len)
\end{itemize}
\textit{ExtflashInterface\_restore} holt zwei aufeinanderfolgende Seiten (eine Zelle) aus dem Speicher und schreibt sie in den Buffer. \textit{ExtflashInterface\_flush(uint16\_t cell)} schreibt die beiden Seiten im Buffer an die angegebene Stelle im Speicher. \textit{ExtflashInterface\_agent\_restore} und \textit{ExtflashInterface\_agent\_flush} holen die Zelle eines bestimmten Agenten in den Speicher und schließlich sind \textit{ExtflashInterface\_write} und \textit{ExtflashInterface\_read} für Datenzugriffe im Buffer zuständig und können Daten lesen beziehungsweise schreiben.
\paragraph{Speicherinterface}
Das Speicherinterface stellt den Agenten den externen Flashspeicher zur Verfügung. Jedem Agenten werden dafür zwei Seiten zugeordnet. Ruft er nun die Funktionen \textit{MemoryInterface\_readComponentCell(uint8\_t componentCount, uint8\_t cell, uint8\_t* result, uint8\_t length)} oder \textit{MemoryInterface\_writeComponentCell(uint8\_t componentCount,uint16\_t cell, uint8\_t* data, uint8\_t length)} auf, wird geprüft, ob die Zelle des aktuellen Agenten bereits im Buffer ist. Falls nicht, werden die aktuellen Bufferdaten gesichert und es werden die Daten des aktiven Agenten geladen.
\paragraph{Treiber Lichtschranken}
Durch den Lichtschrankentreiber werden zwei Funktionen zur Verfügung gestellt. Zum einen ist es die Funktion \textit{void photosensor\_drv\_init(void)}. In dieser werden alle nötigen Eingänge der \textsc{Mica}z-Module initialisiert. Zum anderen wird durch den Treiber die Funktion \textit{uint8\_t get\_photosensors()} implementiert. Durch die Funktion kann der Zustand der Lichtschranken abgefragt werden. Dabei steht eine 1 für eine unterbrochene und eine 0 für eine offene Lichtschranke.

\paragraph{Interface Lichtschranken}
Über das Interface zur Lichtschranke werden folgende drei Funktionen bereitgestellt:
\begin{itemize}
  \item void PhotosensorInterface\_init(void)
  \item uint8\_t PhotosensorInterface\_is\_bay\_occupied(uint8\_t i)
  \item uint8\_t PhotosensorInterface\_num\_packages(void)
\end{itemize}
Durch die Funktion \textit{void PhotosensorInterface\_init(void)} werden die Lichtschranken über den Treiber initialisiert. Dafür wird lediglich die Funktion \textit{void photosensor\_drv\_init(void)} aus dem Treiber aufgerufen.

Die zweite oben aufgeführt Funktion wird genutzt, um zu überprüfen, ob eine bestimmte Lichtschranke unterbrochen wurde oder nicht. Dafür wird der Funktion ein Wert übergeben, der die zu überprüfende Lichtschranke enthält. Ist der übergebende Wert größe als vier, mehr Lichtschranken wurden nicht verbaut, oder kleiner als eins wird eine 0 zurückgegeben, was als nicht ausgelöste Lichtschranke zu interpretieren ist.

\paragraph{Treiber Funkmodul}
Der Treiber für das Funkmodul ist zuständig für die korrekte Funktionalität der drahtlosen Kommunikation zuständig und greift dafür auf den Contiki-Kommunikationsstack \textit{RIME} zu. Auf das Coktiki-interne Atomic Broadcast Protokoll wird durch den Treiber ein Networkflooding augesetzt, das eine zuverlässigere Nachrichtenübermittlung ermöglicht. Dabei werden folgende Funktionen zur Verfügung gestellt:\begin{itemize}
  \item void radio\_open(struct radio\_conn *c, uint16\_t channel, const struct radio\_callbacks *u)
  \item void RadioDriver\_sendmessage(uint8\_t* msgtext, uint8\_t length)
  \item void RadioDriver\_receivemessage(struct radio\_conn *c)
  \item void RadioDriver\_init(void)
\end{itemize}


\paragraph{Treiber UART-Schnittstelle}
Der UART-Treiber ermöglicht die Kommunikation der \textit{Mica}z-Module über den USB-Port. Dafür wurden vom Treiber die folgenden Funktionen entwickelt.
\begin{itemize}
  \item void UartDriver\_send(uint8\_t *buf, uint8\_t size)
  \item int UartDriver\_line\_input\_byte(unsigned char c)
  \item void UartDriver\_line\_init(void)
\end{itemize}
und zusätlich der Prozess
\begin{itemize}
  \item UartDriver\_recv\_process
\end{itemize}

Die Initialisierung der UART-Schnittstelle findet in der Methode \textit{void UartDriver\_line\_init(void)} statt. Dabei wird ein Ringbuffer, der für den Empfang der Zeichen zuständig ist, initialisert. Außerdem wird der für die Verarbeitung verantwortliche Prozess gestartet.

Die Funktion \textit{void UartDriver\_send(uint8\_t *buf, uint8\_t size)} wird für das Senden über die UART-Schnittstelle benötigt. Dabei wird ein Zeiger auf die Adresse der zusendende Nachricht und die Länge der Nachricht an die Funktion übergeben. Zu Anfang der Funktion wird geprüft, ob die zu sendende Nachricht kleiner als fünf Byte ist. Wenn die Nachricht kürzer als fünf Byte ist, dann wird die Nachricht mit Bytes mit dem Wert 0x00 aufgefüllt. Die Nachricht wird dann byteweise über die UART-Schnittstelle ausgegeben.

Die Methode \textit{int UartDriver\_line\_input\_byte(unsigned char c)} wird zum einlesen über die UART-Schnittstelle verwendet. Es handelt sich hierbei um einen Callback, der von einem Interrupt immer dann aufgerufen wird, wenn ein Byte empfangen wird. Dafür wird überprüft, ob ein Überlauf vorliegt. Wenn dies der Fall ist, wird das Zeichen komplett bis zum Zeilenende ignoriert und der Parameter für den Überlauf auf 0 gesetzt. Wenn genug Platz im Buffer vorhanden ist, wird das empfangene Zeichen eingelesen und im Buffer gespeichert. Kann das Zeichen nicht mehr gespeichert werden, wird der Parameter für den Überlauf auf 1 gesetzt. Zum Schluss wird der Prozess \textit{UartDriver\_recv\_process} gepollt. Dieser ist für die Verarbeitung der empfangenen Nachricht verantwortlich. Dabei wird das eingehende Byte in einen Buffer geschrieben. Wenn der Buffer eine Länge von fünf Byte hat, wird dieser an das Communication Interface weitergereicht.

\paragraph{Interface UART-Schnittstelle}
Durch das UART-Interfache werden folgende Funktionen zur Verfügung gestellt:
\begin{itemize}
  \item void UARTInterface\_drive\_to\_entry(uint16\_t rampid)
  \begin{itemize}
    \item Gibt den Befehl aus, zum Eingang der Rampe mit der Rampen-ID rampid zu fahren
  \end{itemize}
  \item void UARTInterface\_drive\_to\_exit(uint16\_t rampid)
  \begin{itemize}
    \item Gibt den Befehl aus, zum Ausgang der Rampe mit der Rampen-ID rampid zu fahren
  \end{itemize}
  \item void UARTInterface\_how\_cost\_job(uint16\_t startid, uint16\_t targetid)
  \begin{itemize}
    \item Stellt die Frage, wie hoch die Kosten sind ein Paket von Startrampe (startid) zur Zielrampe (targetid)
  \end{itemize}
  \item void UARTInterface\_give\_package(void)
  \begin{itemize}
    \item Befehl Paket an die Rampe abzugeben
  \end{itemize}
  \item void UARTInterface\_take\_package(void)
  \begin{itemize}
    \item Befehl Paket von Rampe entgegenzunehmen
  \end{itemize}
\end{itemize}
Alle Funktionen sind dazu nötig um Befehle an die Teilgruppe Drive zusenden. Mit diesen können Nachrichten an den Volksbot über die USB-Schnittstelle versandt werden.
