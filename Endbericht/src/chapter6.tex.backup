\section{Teilbericht Materialfluss}
Das Ziel der Materialfgruppe ist das dezentrale Management der Fördereinheiten auf der Rampen und auf dem Volksbots.
\subsection{Lastenheft}
Aus einem neutzwerk drathlosen Sensorknoten müssen die Rampen auf mikrocontrollerebene miteiander kommunizieren können und die Fördereinheiten steuern.
Die Steuerung und Überwachung muss dezentral durch softwareagenten ablaufen. Die Mikrocontrollern dienen als Agentenplattform und bei der Entwicklung muss 
auf Leistungsressourcen (CPU, Kommunikationsbandbreite, Speicher) geachtet werden.
\paragraph{Produktfunktionen}
\begin{enumerate}
 \item \textbf{Aktorik/sensorik}: Die Rampen verfügen über Magnetstreifen zum Vereinzeln der Pakete und Lichtschranken 
 zum Erkennen von ein- bzw. ausgehenden Pakete. An den ATMega128 Mikrocontroller der Rampen werden die Lichtschranken und Magnetstifte angeschlossen.
 \item \textbf{Echtzeitsteuerung}: An den ATMega128 Mikrocontroller der Rampen werden die Lichtschranken und Magnetstifte angeschlossen. Der Controller führt die
 Befehle für die rampe aus. 
 \item \textbf{Kommunikation}:Die Micaz-Module kommunizieren drahtlos mit anderen Rampen und Volksbot
 \item \textbf{Synchronisation}: Die Simulation wird über ein Micaz-Modul an die drahtlose Kommunikation angebunden. Die Synchronisation der Zustand erfolgt
  mittels vorhandenem Ice Interface.
 \item \textbf{Disposition}:Die Controller kennen den Belegungszustand der Rampe und generieren entsprechend Aufträge, die sie an die Fahrzeuge vergeben. 
 Das ganze soll nach dem FIFO-Verfahren ablaufen.
 \item \textbf{Übergabe}: Wenn eine Ein- oder Auslagerung an einer Rampe ausgeführt werden soll, so übernimmt der Controller der Rampe die Kontrolle
 über die Fördereinheit des Fahrzeugs und sorgt dafür, dass das Paket verladen wird
 \item \textbf{Kooperation}: Einsatz Kooperativer Lösungsstrategien für die Materialflusssteuerung. Überwachung und Steuerung mittels Multi-Agentensystem
\end{enumerate}

\subsection{Komponentenbeschreibung}
\subsubsection{Rampe}
Eine rampe dient zur Aufnahme und Ausgabe von paketen. Es kann bis zu 4 paketen aufnehmen. Es gibt eine Eingangsseite und eine
Ausgangsseite. Die Pakete bewegen sich nur in eine Richtung. Jeder Slot wird mit einer Lichtschranke überwacht und ausfahrbare 
Bolzen vereinzeln die Pakete. Ein Micaz Controller ist die Agentenplattform. 
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{SkizzeRampe.png}
	\caption{Skizze einer Rampe\cite{Stasch:Hahn}}
	\label{SkizzeRampe}
\end{figure}

\subsubsection{Mikrocontroller}
Ein Mikrocontroller ist ein kleiner Computer auf einem einzelnen Halbleiter-Chip. Dazu geh\"ort ein Prozessor,
der Programme ausf\"uhren kann, Arbeits- und Programmspeicher sowie Schnittstellen, die eine Kommunikation mit 
der Umgebung erm\"oglichen sog. Peripheriefunktionen \cite{Wikibooks:2014:Online}. Mit ihnen lassen sich komplexe
Aufgaben l\"osen, f\"ur die sonst ein aufw\"andiger Schaltungsaufbau notwendig w\"are. Standardm\"a{\ss}ig sind folgende Bestandteile in Mikrocontrollern integriert:
CPU, SRAM und Flash-Speicher f\"ur den Programmcode. Weiterhin bieten MCs analoge und digitale Ports, 
mehrere AD/DA-Wandler, Timer und Schnittstellen zur Kommunikation mit der Au\"{ss}enwelt \cite[vgl.]{Viktor:Seib:2014:Online}.
In der nachstehenden Abbildung ist der allgemeine schematische Aufbau eines Mikrocontrollers in folgender Abbildung dargestellt.
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{Aubau_eines_Mikrocontrollers.png}
	\caption{schematischer Aufbau eines Mikrocontrollers \cite{habil:Ostermeye:2014:Online}}
	\label{Aufbau eines Mikrocontrollers}
\end{figure}

\begin{itemize}
\item Prozessor (CPU)
\begin{itemize}
          \item Arithmetic Logic Unit kurz ALU (Rechenwerk)
          \item 32 GPIO-Register (Arbeitsregister f\"ur ALU)
          \item Programmcounter (Programmposition)
					\item Statusregister (Status der aktuellen Operation) 
\end{itemize}
\item Speicher
\begin{itemize}
          \item SRAM Datenspeicher (Static Random-Access Memory)
					\item Flash ROM Programmspeicher (Read Only Memory)
					\item EEPROM Festspeicher (Electrically Erasable Programmable Read-Only Memory)
\end{itemize}
\item Peripheriekomponenten
    \begin{itemize}
          \item I/O-Ports Prim\"arfunktion der Pins (Ein- und Ausg\"ange)
          \item A/D-Wandler (Einlesen von analogen Spannungen)
          \item Timer/Counter (Zeitintervall-/PBM-Generator)
					\item Interrupts (Programmunterbrechungsroutinen)
					\item USART, I2C/TWI und SPI (Kommunikationsschnittstellen)
					\item Watch-Dog (Absicherung gegen Systemfehler)
					\item ISP (Schnittstelle zum \"{U}bertragen des kompilierten Programms)
	\end{itemize}
\end{itemize}
Mikrocontroller sind im heutigen Leben weit verbreitet und es gibt eine viele Anzahl von Herstellern, die mikrocontroller anbieten.
Im folgenden werden einige Hersteller mit ihren MC-Familien beispielhaft aufgef\"urt:
\begin{itemize}
\item Intel (8051-Serie)
\item Renesas (H8)
\item Zilog (Z8)
\item Microchip (Pic)
\item Freescale (fr\"uher Motorola) (68HC08 bzw. 68HCS08)
\item Atmel (AVR, 8051-Serie)
\end{itemize}
F\"ur das Projekt FAISE wurde das Atmel-Serie eingesetzt. Es sind Mikrocontroller mit erweiterten Peripherien und Funktionen, 
die auf der 8-Bit-AVR-Architektur basieren. Bei AVR handelt es sich um einen RISC-Kern, der an der Universit\"at von Trondheim 
in Norwegen entwickelt und von Atmel aufgekauft wurde. Die CPU besitzt 32 allgemeine 8-Bit Register (general purpose registers) 
und ist in der Lage in einem einzigen Taktzyklus Daten aus zwei beliebigen Registern in die ALU zu laden, diese zu verarbeiten 
und das Ergebnis in einem beliebigen Register zu speichern \cite[vgl.]{Viktor:Seib:2014:Online}. Die Konfiguration eines Atmega 8 der Firma Atmel sieht so aus:
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{Atmel8.png}
	\caption{Atmel 8 \\ \url{(http://www.ids.tu-bs.de/tl\_files/Lehre/Vorlesungen/Simulation2/Einfuehrung\_in\_die\_MC\_Programmierung\_Teil1.pdf)}}
	\label{Atmel 8}
\end{figure}
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{LegendeAtmel8.png}
	\caption{Atmel 8 \url{(http://www.ids.tu-bs.de/tl\_files/Lehre/Vorlesungen/Simulation2/Einfuehrung\_in\_die\_MC\_Programmierung\_Teil1.pdf)}}
	\label{Legende Atmel8}
\end{figure}
\begin{itemize}
\item Pins f\"ur die Minimalbeschaltung
\begin{itemize}
          \item Spannungsversorgung
          \item ReferenzspannungTaktgeber
          \item Reset      
					\end{itemize}
\item Prim\"arfunktion eines Pins
\begin{itemize}
          \item Ein- bzw. Ausgang
					\end{itemize}
\item Sekund\"arfunktion des Pins
\begin{itemize}
          \item A/D-Wandlereingang
          \item Ext. Interrupt
          \item PBM-Ausgang   
\end{itemize}
\end{itemize}
F\"ur die Programmierung der AVR-Controller gibt es eine kostenlose Entwicklungsumgebung AVR-Studio, die das Einbinden des Compilers problemlos erlaubt.

\subsubsection{Sensorik/ Aktorik}
Hauptziel der Teilgruppe Materialfluss ist das Management von Paketen auf einer Rampe. Die Aufgabe der Sensorik ist dabei, 
die mit Lichtschranken ausgestatteten Rampen Paketen zu detektieren und auf \"Anderung der Position der Paketen zu reagieren.
Die Lichtschranken bestehen aus einer Lichtstrahlenquelle (dem Sender) und einem Sensor (dem Empf\"anger) f\"{u}r diese Strahlung.
Als Lichtquelle kommt Infrarotlicht zum Einsatz und der Vorteil besteht in der einfachen Einstellung des Sensorsystems durch den
sichtbaren Lichtfleck. Das Funktionsprinzip der Lichtschranke besteht darin, der zu  \"andernden Zustand durch die Lichtintensit\"at 
mit dem Sensor zu registrieren. 
Die Rampen werden auf Hardwareebene um eine Aktorik zum Arretieren der Kisten erg\"anzt. Diese Aktoren (in unserem Fall die
eingesetzte Bolzenpaar) sind f\"ur das Ausf\"uhren von Bewegungen zust\"andig. Sie sind aktive Stellelemente, die in der 
Antriebs - und Steuerungstechnik, die vom  Mikrorechner angesteuert werden und das Verhalten des Prozesses durch das vom 
Sensor kommende Signal in einer gew\"{u}nschten Weise zu erm\"oglichen. In dieser allgemeinen Darstellung stehen die 
Ausgangssignale eines Sensors und die Stellsignale der Aktoren mit einem
Informationsverarbeitungssystem (IVS) in Verbindung.

\subsubsection{Contiki}
Contiki ist ein Open Source Echtzeitbetriebssystem, das bei uns in der PG auf den MICAz-Modulen eingesetzt wird.
Contiki bietet einen einfachen ereignisgesteuerten Betriebssystemkern mit sogenannten Protothreads, optionalem 
pr\"aemptiven Multiprogramming, Interprozesskommunikation via Messagepassing durch Events, eine dynamische Prozessstruktur
mit Unterst\"utzung f\"ur das Laden und Entladen von Programmen, nativen TCP/IP-Support \"ber den uIP TCP/IP-Stack und eine 
grafische Benutzerschnittstelle, welche direkt auf einem Bildschirm oder als virtuelle Anzeige \"uber Telnet oder VNC genutzt werden kann \cite{Wikipedia:2013:Online}.
 
\paragraph{Systemarchitektur}
Ein laufendes Contiki System besteht aus dem Kernel, Bibliotheken, Prozessen und dem Programm-Lader, mit dem Anwendun-
gen zur Laufzeit aus dem Speicher oder \"uber ein Funkmodul geladen werden k\"onnen. Die unter stehende Abbildung zeigt die Aufteilung des Betriebssystems in zwei Teile. 
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{Systemarchitektur_Contiki.png}
	\caption{Adam Dunkels, Bj\"orn Gr\"onvall, Thiemo Voigt: Contiki - a Lightweight and Flexible Operating System for Tiny Networked
	Sensors. \url{(Quelle:http://www.up.edu.ps/ocw/upinar/moodledata/872/moddata/assignment/970/1287/10.1.1.59.2303.pdf)}}
	\label{Systemarchitektur von Contiki}
\end{figure}
Der Core ist ein Basissystem und besteht aus dem Kernel, Bibliotheken, Ger\"{a}tetreiber und der Programm-Lader. 
Im allgemeinen sind \"Anderungen am Core nicht vorgesehen und nur unter Verwendung eines speziellen Bootloader m\"oglich. 
Die konkrete Aufteilung des Systems in Core und ladbare Programme wird beim Kompilieren des Systems entschieden und h\"angt 
von der Hardware-Plattform ab \cite[vgl.][S. 7]{Walter:2010}. Ger\"atetreiber werden als Bibliotheken implementiert. 

\paragraph{Events}
In Contiki kommunizieren Prozesse \"uber Events. Auch der Kernel versendet Events, um Prozesse \"uber ihren Status 
(Init, Continue, Exit) oder \"uber abgelaufene Timer zu Informieren. Zur Identifikation stehen dabei Event IDs zur 
Verf\"ugung. Die Event IDs 0-127 k\"onnen vom Benutzer frei vergeben werden, w\"ahrend die Prozess IDs ab 128 vom 
System genutzt werden. Grunds\"atzlich unterscheidet Contiki zwischen synchronen und asynchronen Events. 
\begin{itemize}
\item Asynchronen Events
\end{itemize}
Asynchrone Events sind eine Form der Deferred Procedure Call: asynchrone Events werden vom Kernel in einer 
Warteschlange gespeichert. Die Scheduling-Funktion des Kernels l\"auft nach Systemstart in einer Endlosschleife. 
In jedem Durchlauf wird ein Event aus der Schlange entnommen und wird einige Zeit sp\"ater an den Zielprozess weitergeleitet.
\begin{itemize}
\item Synchronen Events
\end{itemize}
Synchrone Events gleichen einem Funktionsaufruf. Die werden ohne Umweg \"uber die Warteschlange direkt an den Empf\"anger-Prozess
zugestellt \cite[vgl.][S. 7]{Walter:2010}.  Mit der Funktion process\_post\_synch(\&example\_process, EVENT\_ID, msg) wird gezielt ein 
Prozess aufgerufen (ein Broadcast ist nicht m\"oglich). W\"ahrend der aufgerufene Prozess aktiv ist, blockiert der Aufrufer und 
setzt seine Ausführung erst fort, wenn der aufgerufene Prozess die Kontrolle wieder abgibt.

\paragraph{Prozesse}
Prozesse in Contiki implementieren ein Konzept namens Protothreads. Dies erlaubt es Prozessen, ohne den Overhead und die langen 
Prozesswechselzeiten von normalen Threads auszukommen. Gleichzeitig k\"onnen trotzdem andere Prozesse ausgef\"uhrt werden, falls
ein Prozess auf ein Event (Timer, Nachricht von anderem Prozess...) warten muss. F\"ur die Entwicklung mit Prozessen ist wichtig, 
dass nicht-statische Variablen nicht zwischen zwei Aufraufen erhalten bleiben. Der relevante Status eines Prozesses sollte daher 
mithilfe von statischen Variablen abgelegt werden (siehe Variable i im folgenden Beispiel:

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{Beispielprozess.png}
	\label{Beispielprozess}
\end{figure}
In Zeile 1 wird der Prozess initialisiert und in Zeile 2 automatisch beim Boot von Contiki gestartet. Zeile 4 beinhaltet die
Deklaration. So k\"onnen andere Prozesse diesem Prozess Events (mit oder ohne Daten) schicken, auf die unser Beispielprozess 
mit ev und data zugreifen kann. Zeile 6 kennzeichnet den Beginn der tats\"achlichen Ablauflogik. Code \"uber dieser Zeile wird 
bei jedem Prozessaufruf ausgef\"uhrt, dies wird jedoch in den meisten F\"allen nicht ben\"otigt. Zeile 13 schlie{\ss}lich beendet
den Prozess und entfernt ihn aus der Prozess-Liste des Kernels. In diesem Beispiel wird die Zeile jedoch nie erreicht, sodass er
Prozess immer wieder aufgerufen wird, bis er von einem anderen Prozess beendet wird.
Wichtige Funktionen in Prozessen:
\begin{itemize}
\item PROCESS\_WAIT\_EVENT()- Wartet auf ein beliebiges Event, bevor die Ausf\"{u}hrung fortgesetzt wird
\item PROCESS\_WAIT\_EVENT\_UNTIL(condition) - Wartet auf ein beliebiges Event, setzt die Ausf\"{u}hrung aber nur fort, wenn die Bedingung erf\"{u}llt ist
\item PROCESS\_WAIT\_UNTIL() - Wartet, bis die Bedingung erf\"ullt ist. Muss den Prozess nicht zwangsl\"{a}ufig anhalten
\end{itemize}
Prozesse k\"onnen \"uber Events (siehe Events) oder Polling-Anfragen kommunizieren.  Polls sind Events mit hoher Priorit\"at und 
k\"onnen genutzt werden, um den angerufenen Prozess so schnell wie m\"oglich auszuf\"uhren. Sie
sind besonders bei der Abarbeitung von Hardware-Interrupts wichtig, da Interrupts-Handler keine Events, sondern nur
Polling-Anfragen absetzten d\"urfen \cite[vgl.][S. 7]{Walter:2010}.
\subsection{Gesamtarchitektur}
Zur Umsetzung der dezentralen Steuerung werden Softwareagenten eingesetzt. Bei Software-Agenten handelt es sich um Prozesse, die lose gekoppelt 
und leicht austauschbar sind \cite[vgl.][S. 31-37]{GH:2010}. Es existieren verschiedene Definitionen eines Agenten, von denen
sich keine als Standard etablieren konnte. Die hier verwendete Definition stammt von
Brenner, Zarnekow und Wittig. Sie definieren einen Agenten als „ ... ein Softwareprogramm,
das für einen Benutzer bestimmte Aufgaben erledigen kann und dabei einen Grad an
Intelligenz besitzt, der es befähigt, seine Aufgaben in Teilen autonom durchzuführen und mit
seiner Umwelt auf sinnvolle Art und Weise zu interagieren“\cite{BZW:1998}. Die Fähigkeit von Agenten, miteinander zu kommunizieren 
und zu interagieren, ermöglicht das Erstellen eines Multiagentensystems (MAS). Ein wesentlicher Vorteil von MAS 
bzw. von verteilten Steuerungssystemen ist die Fähigkeit, dynamisch auf Veränderungen zu reagieren. Ein Beispiel für eine solche Veränderung ist der
Ausfall einer Steuerungseinheit bzw. eines Agenten. Der Ausfall einer Einheit hat nicht unbedingt zur Folge, dass das gesamte System ausfällt. 
Die restlichen Einheiten können sich eigenständig auf eine solche Veränderung einstellen und diese beim weiteren Ablauf
berücksichtigen\cite[S. 13]{Roidl:2012}. Diese Eigenschaft bringt eine ganze Reihe von Vorteilen für ein dezentral
gesteuertes Materialflusssystem mit sich.\\
Die Modellierung von agentenbasierten Systemen für industrielle Bereiche wird durch die
Entwicklung von Standards festgelegt. Diese beschreiben Modelle für die Architektur
sowie die Kommunikation zwischen Agenten. Die FIPA (Foundation of Intelligent Physical Agents) ist das Standardisierungsorgan
für Agentensysteme.  Seit der Gründung 1996 in der Schweiz wurden verschiedene
Standardisierungen ver
̈ffentlicht, so zum Beispiel auch die Agentenkommunikati-
on (Agent Communication), die als FIPA/ACL (Agent Communication Language,
ACL) bekannt geworden ist.
Die Systemarchitektur der Materialfgruppe lehnt sich an der AUTOSAR Softwarearchitektur. 
Die nächste Abbildung zeigt den Aufbau der Softwarearchitektur:
\begin{figure}[h!]
	\centering
		\includegraphics[width=0.9\textwidth]{ArchitekturMicazRampe.png}
	\caption{Architektur Micaz Rampe\cite{Stasch:Hahn}}
	\label{ArchitekturMicazRampe}
\end{figure}
\subsubsection{Hardware Level}
Auf der Hardwareebene werden die Treiber für die Steuerung der Lichtschranke und Bolzen implementiert. Die Treiber bekommen ein
allgemeines Interface für die Agenten RTE.
\subsubsection{BackgroundLevel}
Auf dieser Ebene werden der Agenten RTE alle Funktionalitäten zur Verfügung gestellt. Das RTOS stellt Infrastruktur wie z.B. Task Management, 
Timing, Events usw. Die Driver Ebene kümmert sich auf um die Schnittstellen/Pins des Controllers wie z.B. Protokolle angeschlossener
Devices\cite[S. 26]{Stasch:Hahn}. Die aufgabe des service ist es, Funktionen für spezielle Anwendungen zur Verfügung zu stellen.
Darüber kommen die Interfaces, diese sind nötig damit bestimmte Funktionen immer gleich der Agenten RTE zur Verfügung gestellt werden 
auch wenn der Service anders ist oder wenn ein Service verschiedene Interfaces bedienen soll\cite[S. 26]{Stasch:Hahn}.
\subsubsection{Agent Level}
Auf diesem Level werden die Verschiedene Agenten implementiert. Die Agenten RTE soll den Agenten ihnen alle benötigten Schnittstellen zur
Verfügung stellen. Sie soll die Agenten aktivieren und deaktivieren können und die Kommunikation zwischen den Agenten managen
(Messages innerhalb und außerhalb der Plattform trennen)\cite[S. 26]{Stasch:Hahn}. 
\paragraph{Plattformagent}
Jeder Plattformagent ist für die Steuerung von der verantwortlichen Rampe zuständig.
Der Plattform Agent kümmert sich um die Annahme und Abgabe der Pakete mit den Volksbots. Er
hat die alleinige Zugriffsrechte auf die Lichtschranken und ausfahrbaren Stifte. Er überwacht auch die reale Position 
der Pakete und damit auch deren Reihenfolge.
\paragraph{Orderagent}
Der Orderagent spielt die Rolle der alten Materialflussrechner im Materialflusssystem. Seine aufgabe liegt bei der Bearbeitung der aufträge
wo und wann die ware zu sein hat. Sie befinden sich auf jeder Plattform und können den Paketen ihre Destination (Zielmodul)mit Prioritäten (z.B.
eine Ausgangszuweisung zu einem näheren Zeitpunkt hat höhere Priorität als eine Spätere und diese ist höher als eine Zwischeneinlagerung usw.) 
und ihre Agent ID zuweisen\cite[S. 30]{Stasch:Hahn}. 
\paragraph{Paketagent}
Der Paket Agent repräsentiert die physische Fördereinheit. Beim Eintritt im System kümmert sich der Paketagent um 
eine destination und schon bei vorhandener Destination gibt er dem Routingagent sein ziel mit Priorität zur weiteren Planung durch.
Er aktualisiert regelmäßg seinen Status und gibt neue Routinganfragen wenn sich seine Destination ändert.
Wenn das physische Paket das Modul wechselt, wandert der paketagent auch von der jeweiligen Plattform zur nächsten. 
Da jeder Paket Agent gleich ist wird der Plattformwechsel realisiert, in dem seine Parameter weitergegeben
werden, ein neuer Paket Agent auf der nächsten Plattform aktiviert wird und auf der vorigen Plattform deaktiviert\cite[S. 31]{Stasch:Hahn}.
\paragraph{Routingagent}
Der Routingagent kümmern sich um die Wegplanung der Agenten im Materialfluss. Der Weg bestimmt die Hops über welche Module das Paket geleitet wird.
Das Ziel der Paket-Agents ist es, an ihrem Ziel in der effizientesten Art und Weise durch die Wahl optimaler Routen 
mit minimalen Abständen und kürzesten Fahrzeiten anzukommen. Das heisst, dass Die Planungsanfragen
von Paketagent kommen und bei erfolgter Planung oder neu Planung werden die betroffenen Paket Agenten informiert. Für die Planung der 
Route wurde ein Routingalgorithmus entwickelt und implementiert.

