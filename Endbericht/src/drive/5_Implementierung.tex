\subsection{Implementierung}

Im folgenden Abschnitt wird auf die Implementierung der Funktionen des Transportroboters eingegangen. Dabei werden die zwei Teilabschnitte, die Implementierung der Navigation und die Implementierung der Paketübergabe, betrachtet. Der Großteil der Implementierung wurde in den ROS-Packages \textit{epos2\_control} und \textit{simple\_navigation\_goals} realisiert.

\subsubsection{Ablaufkonzept}

Die Abbildung \ref{fig:Ablaufkonzept} gibt einen Überblick über die implementierten Funktionen und deren Ablaufreihenfolge bei dem Transport von Paketen. Nach dem Eingang eines Auftrages über das MICAz-Modul wird dieses in ein Navigationsziel umgesetzt. Neben der Position auf der Umgebungskarte wird auch die Zielhöhe des Hubs dem Auftrag entnommen. War die Navigation zur Zielposition und die Steuerung des Hubs erfolgreich beginnt die Förderbandsteuerung je nach Auftrag mit dem Be- bzw. Entladen. Die Auswertung der Lichtschranken der Fördereinheit ermöglicht die Zustandserkennung der Paketübergabe. Nach erfolgreicher Übergabe ist der Volksbot bereit ein folgendes Ziel anzufahren oder einen neuen Auftrag entgegenzunehmen.

\begin{figure}[h!]
 \centering
		\includegraphics[width=1\textwidth]{drive/Ablaufkonzept.png}
	\caption{Ablaufkonzept}
	\label{fig:Ablaufkonzept}
\end{figure}


\subsubsection{Implementierung der Navigation}
Nach erfolgreicher Inbetriebnahme der Hardware des Volksbots wurde die Odometrieberechnung anhand der zurückgelegten Strecke der Räder implementiert. Die Berechnung der zurückgelegten Wegstrecke und der Drehung des Roboters erfolgt über folgende Formeln\cite[S. 1]{Der:2000}:

\begin{equation}
\triangle s = \dfrac{\triangle R + \triangle L}{2}
\end{equation}
 
\begin{equation}
\triangle \alpha = \dfrac{\triangle R - \triangle L}{D}
\end{equation} 

Die Daten der Wegstrecke und der Drehung des Roboters werden genutzt, um mit folgenden Formeln die x- und y-Position des Roboters zu berechnen:

\begin{equation}
x = x(t-1) + (\triangle s * \cos (\alpha (t-1) + \triangle \alpha))
\end{equation} 

\begin{equation}
y = y(t-1) + (\triangle s * \sin (\alpha (t-1) + \triangle \alpha))
\end{equation} 

Der Drehwinkel des Roboters ergibt sich aus der Addition des vorherigen Winkels mit der zuletzt durchgeführten Änderung des Drehwinkels. \autoref{lst:odom} zeigt die Implementation der Odometrie.

\lstinputlisting[language=C++, style=customc, captionpos=b, caption={Implementation der Odometrieberechnung}, label=lst:odom]{src/drive/lst/Odometrie.cpp}

Die Daten der Odometrie werden zur Lokalisierung des Roboters innerhalb einer mit dem SICK LMS100 Laserscanners erstellten Umgebungskarte verwendet. Die Implementierung erfolgte ebenso wie bei der Entwicklung der Treiber im \textit{epos2\_control}-Package. Bei der Erstellung der Umgebungskarte wurde auf das \textit{Gmapping}-Package von ROS zurückgegriffen. Der darin enthaltene Algorithmus nutzt die Daten des Laserscanners, um während der Fahrt des Roboters aus seiner erfassten Umgebung eine Karte zu erstellen. Zur Visualisierung der Karte und der Daten des Laserscans wurde \textit{Rviz}, ein Visualisierungstool innerhalb der ROS-Umgebung verwendet. Mit Hilfe von Rviz ist es neben der Visualisierung unter anderem möglich die initiale Position des Roboters, sowie Navigationsziele innerhalb der Karte festzulegen. (Screenshot Rviz) Mit dem Ziel den auftretenden Abweichungen der Odometrieberechnung entgegenzuwirken, wurde das \textit{adaptive Monte Carlo Localisation}-Package (AMCL) implementiert. Vereinfacht formuliert, nutzt dieses Verfahren die Daten des Laserscans und der Karte, um mit Hilfe der Merkmale des aktuellen Scans und der zugrundeliegenden Daten der Kartenrepräsentation eine Schätzung der Position des Roboters auszuführen. \cite[S. 6]{Bischoff:2004}
Eine funktionsfähige Selbstlokalisation ist die Grundlage für eine erfolgreiche autonome Navigation in der Umgebung des Roboters. Das ROS-Framework stellt mit dem \textit{move\_base}-Package die nötigen Funktionen für die Navigation bereit. Das Package hat den Dijkstra-Algorithmus zur Wegplanung implementiert und nutzt zwei parametrisierbare Costmaps, um Eigenschaften wie z.B. den Mindestabstand zu Hindernissen oder das Verhalten bei Planungsfehlern festzulegen. Nach der Planung des Weges werden automatisch die passenden Steuerbefehle generiert. Falls der Volksbot in eine unvorhergesehene Situation gerät und seine geplante Route nicht mehr gültig ist, kommen Rettungs-Funktionen des Packages zum Einsatz. Dabei wird eine Rotation um die eigene Achse des Roboters durchgeführt, um einen geeigneten neuen Weg zu finden. Durch die Anpassung von Ziel-Toleranzen kann das Verhalten des Roboters in der Nähe der Zielposition beeinflusst werden. Je geringer die Toleranzen, desto länger benötigt der Roboter die gewünschte Position einzunehmen.

\subsubsection{Implementierung der Paketübergabe}
Damit der Austausch der Pakete mit den Komponenten des Materialflusses erfolgen kann, musste die Kommunikation über die MICAz-Module und Automatismen zur Anpassung der Hub-Position an die Höhe der jeweiligen Rampe implementiert werden. Nachdem ein Auftrag vom Materialfluss empfangen wurde, wird die Annahme des Auftrags dem Materialfluss bestätigt und der Auftrag in ein passendes Navigationsziel auf der Umgebungskarte umgesetzt. Für den Prozess des Entschlüsselns der Nachrichten des Materialflusses wurde das ROS-Package namens \textit{simple\_navigation\_goals} implementiert. Die Kommunikation über das MICAz-Modul ist im Code der \textit{r2Serial.cpp} des \textit{epos2\_control}-Packages verankert. In diesem Package befindet sich auch die \textit{TankSteering.cpp}-Datei, welche Funktionen der Hub- und Förderbandsteuerung enthält. \autoref{lst:flow} zeigt die Förderbandsteuerung für den Aufladevorgang.

\lstinputlisting[language=C++, style=customc, captionpos=b, caption={Implementation der F\"orderbandsteuerung f\"ur den Aufladevorgang}, label=lst:flow]{src/drive/lst/FlowControl.cpp}

Neben der Umsetzung von Funktionen des Roboters senden diese Nodes ROS-interne Nachrichten, welche Informationen über die gewünschte Position des Hubs und das Erreichen der Zielposition enthalten. Im Sequenz-Diagramm der Abbildung \ref{fig:Paketsequenz} ist die Nachrichtenstruktur für den Aufladevorgang eines Pakets aufgezeigt. Der Vorgang startet mit dem Empfang einer Auftrags-Nachricht über das MICAz-Modul. Diese Nachricht enthält die ID der Zielrampe und wird ROS-intern von der \textit{r2Serial}-Node zur \textit{simple\_navigation\_goals}-Node versandt. Diese Nachricht wird in der Node zu einem Navigationsziel und zu einer Zielhöhe für den Hub umgesetzt. Die Zielhöhe wird mitsamt der Zielrampen-ID an die \textit{TankSteering}-Node übergeben. Die Zielrampen-ID wird für die Rückmeldung an die Rampen bei Erreichen des Ziels benötigt. Sobald das Navigationsziel erreicht wurde, sendet die \textit{simple\_navigation\_goals}-Node eine Nachricht an die \textit{TankSteering}-Node, sodass die Hub- und Förderbandsteuerung durchgeführt werden kann. Erreicht die Hubsteuerung die notwendige Höhe, erfolgt die Rückmeldung an die Rampen über eine Nachricht von der \textit{TankSteering}-Node an die \textit{r2Serial}-Node. Es folgt der eigentliche Vorgang der Paketübergabe. Durch die Auswertung der Lichtschranken des Förderbandes wird der Vorgang gestoppt und eine Nachricht über den Ladestatus von der \textit{TankSteering}-Node an die \textit{simple\_navigation\_goals}-Node übermittelt. Folgend können neue Aufträge angenommen oder ein Folgeziel angefahren werden.

\begin{figure}[h!]
 \centering
		\includegraphics[width=1\textwidth]{drive/sequenz.png}
	\caption{Sequenz-Diagramm des Ablaufs der Paketübergabe}
	\label{fig:Paketsequenz}
\end{figure}


